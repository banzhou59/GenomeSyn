.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JSON::Any 3"
.TH JSON::Any 3 "2011-06-07" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JSON::Any \- Wrapper Class for the various JSON classes.
.SH "VERSION"
.IX Header "VERSION"
Version 1.29
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module tries to provide a coherent \s-1API\s0 to bring together the various \s-1JSON\s0
modules currently on \s-1CPAN\s0. This module will allow you to code to any \s-1JSON\s0 \s-1API\s0
and have it work regardless of which \s-1JSON\s0 module is actually installed.
.PP
.Vb 1
\&        use JSON::Any;
\&
\&        my $j = JSON::Any\->new;
\&
\&        $json = $j\->objToJson({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&        $obj = $j\->jsonToObj($json);
.Ve
.PP
or
.PP
.Vb 2
\&        $json = $j\->encode({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&        $obj = $j\->decode($json);
.Ve
.PP
or
.PP
.Vb 2
\&        $json = $j\->Dump({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&        $obj = $j\->Load($json);
.Ve
.PP
or
.PP
.Vb 2
\&        $json = $j\->to_json({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&        $obj = $j\->from_json($json);
.Ve
.PP
or without creating an object:
.PP
.Vb 2
\&        $json = JSON::Any\->objToJson({foo=>\*(Aqbar\*(Aq, baz=>\*(Aqquux\*(Aq});
\&        $obj = JSON::Any\->jsonToObj($json);
.Ve
.PP
On load, JSON::Any will find a valid \s-1JSON\s0 module in your \f(CW@INC\fR by looking 
for them in this order:
.PP
.Vb 3
\&        JSON::XS 
\&        JSON 
\&        JSON::DWIW
.Ve
.PP
And loading the first one it finds.
.PP
You may change the order by specifying it on the \f(CW\*(C`use JSON::Any\*(C'\fR line:
.PP
.Vb 1
\&        use JSON::Any qw(DWIW XS JSON);
.Ve
.PP
Specifying an order that is missing one of the modules will prevent that
module from being used:
.PP
.Vb 1
\&        use JSON::Any qw(DWIW XS JSON);
.Ve
.PP
This will check in that order, and will never attempt to load JSON::Syck. This
can also be set via the \f(CW$ENV\fR{\s-1JSON_ANY_ORDER\s0} environment variable.
.PP
JSON::Syck has been deprecated by it's author, but in the attempt to still
stay relevant as a \*(L"Compat Layer\*(R" JSON::Any still supports it. This support
however has been made optional starting with JSON::Any 1.19. In deference to a
bug request starting with \s-1JSON\s0 1.20 JSON::Syck and other deprecated modules
will still be installed, but only as a last resort and will now include a
warning.
.PP
.Vb 1
\&    use JSON::Any qw(Syck XS JSON);
.Ve
.PP
or
.PP
.Vb 1
\&    $ENV{JSON_ANY_ORDER} = \*(AqSyck XS JSON\*(Aq;
.Ve
.PP
\&\s-1WARNING:\s0 If you call JSON::Any with an empty list
.PP
.Vb 1
\&    use JSON::Any ();
.Ve
.PP
It will skip the \s-1JSON\s0 package detection routines and will die loudly that it
couldn't find a package.
.SH "DEPRECATION"
.IX Header "DEPRECATION"
The original need for JSON::Any has been solved (quite some time ago
actually). If you're producing new code it is recommended to use \s-1JSON\s0.pm which
will optionally use \s-1JSON::XS\s0 for speed purposes.
.PP
JSON::Any will continue to be maintained for compatibility with existing code,
and frankly because the maintainer prefers the JSON::Any \s-1API\s0.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Will take any of the parameters for the underlying system and pass them
through. However these values don't map between \s-1JSON\s0 modules, so, from a
portability standpoint this is really only helpful for those parameters that
happen to have the same name. This will be addressed in a future release.
.Sp
The one parameter that is universally supported (to the extent that is
supported by the underlying \s-1JSON\s0 modules) is \f(CW\*(C`utf8\*(C'\fR. When this parameter is
enabled all resulting \s-1JSON\s0 will be marked as unicode, and all unicode strings
in the input data structure will be preserved as such.
.Sp
Also note that the \f(CW\*(C`allow_blessed\*(C'\fR parameter is recognised by all the modules
that throw exceptions when a blessed reference is given them meaning that
setting it to true works for all modules. Of course, that means that you
cannot set it to false intentionally in order to always get such exceptions.
.Sp
The actual output will vary, for example \s-1JSON\s0 will encode and decode
unicode chars (the resulting \s-1JSON\s0 is not unicode) whereas \s-1JSON::XS\s0 will emit
unicode \s-1JSON\s0.
.ie n .IP """handlerType""" 4
.el .IP "\f(CWhandlerType\fR" 4
.IX Item "handlerType"
Takes no arguments, returns a string indicating which \s-1JSON\s0 Module is in use.
.ie n .IP """handler""" 4
.el .IP "\f(CWhandler\fR" 4
.IX Item "handler"
Takes no arguments, if called on an object returns the internal JSON::* 
object in use.  Otherwise returns the JSON::* package we are using for 
class methods.
.ie n .IP """true""" 4
.el .IP "\f(CWtrue\fR" 4
.IX Item "true"
Takes no arguments, returns the special value that the internal \s-1JSON\s0
object uses to map to a \s-1JSON\s0 \f(CW\*(C`true\*(C'\fR boolean.
.ie n .IP """false""" 4
.el .IP "\f(CWfalse\fR" 4
.IX Item "false"
Takes no arguments, returns the special value that the internal \s-1JSON\s0
object uses to map to a \s-1JSON\s0 \f(CW\*(C`false\*(C'\fR boolean.
.ie n .IP """objToJson""" 4
.el .IP "\f(CWobjToJson\fR" 4
.IX Item "objToJson"
Takes a single argument, a hashref to be converted into \s-1JSON\s0.
It returns the \s-1JSON\s0 text in a scalar.
.ie n .IP """to_json""" 4
.el .IP "\f(CWto_json\fR" 4
.IX Item "to_json"
.PD 0
.ie n .IP """Dump""" 4
.el .IP "\f(CWDump\fR" 4
.IX Item "Dump"
.ie n .IP """encode""" 4
.el .IP "\f(CWencode\fR" 4
.IX Item "encode"
.PD
Aliases for objToJson, can be used interchangeably, regardless of the 
underlying \s-1JSON\s0 module.
.ie n .IP """jsonToObj""" 4
.el .IP "\f(CWjsonToObj\fR" 4
.IX Item "jsonToObj"
Takes a single argument, a string of \s-1JSON\s0 text to be converted
back into a hashref.
.ie n .IP """from_json""" 4
.el .IP "\f(CWfrom_json\fR" 4
.IX Item "from_json"
.PD 0
.ie n .IP """Load""" 4
.el .IP "\f(CWLoad\fR" 4
.IX Item "Load"
.ie n .IP """decode""" 4
.el .IP "\f(CWdecode\fR" 4
.IX Item "decode"
.PD
Aliases for jsonToObj, can be used interchangeably, regardless of the 
underlying \s-1JSON\s0 module.
.SH "AUTHORS"
.IX Header "AUTHORS"
Chris Thompson \f(CW\*(C`cthom at cpan.org\*(C'\fR
.PP
Chris Prather \f(CW\*(C`chris at prather.org\*(C'\fR
.PP
Robin Berjon \f(CW\*(C`robin at berjon.com\*(C'\fR
.PP
Marc Mims \f(CW\*(C`marc at questright.com\*(C'\fR
.PP
Tomas Doran \f(CW\*(C`bobtfish at bobtfish.net\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-json\-any at rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=JSON\-Any <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=JSON-Any>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This module came about after discussions on irc.perl.org about the fact 
that there were now six separate \s-1JSON\s0 perl modules with different interfaces.
.PP
In the spirit of Class::Any, JSON::Any was created with the considerable 
help of Matt 'mst' Trout.
.PP
Simon Wistow graciously supplied a patch for backwards compat with \s-1JSON::XS\s0 
versions previous to 2.01
.PP
San Dimas High School Football Rules!
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007\-2009 Chris Thompson, some rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
