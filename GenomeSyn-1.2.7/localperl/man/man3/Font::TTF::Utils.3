.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Font::TTF::Utils 3"
.TH Font::TTF::Utils 3 "2014-12-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::Utils \- Utility functions to save fingers
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Lots of useful functions to save my fingers, especially for trivial tables
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions are exported
.ie n .SS "($val, $pos) = TTF_Init_Fields ($str, $pos)"
.el .SS "($val, \f(CW$pos\fP) = TTF_Init_Fields ($str, \f(CW$pos\fP)"
.IX Subsection "($val, $pos) = TTF_Init_Fields ($str, $pos)"
Given a field description from the \f(CW\*(C`DATA\*(C'\fR section, creates an absolute entry
in the fields associative array for the class
.ie n .SS "TTF_Read_Fields($obj, $dat, $fields)"
.el .SS "TTF_Read_Fields($obj, \f(CW$dat\fP, \f(CW$fields\fP)"
.IX Subsection "TTF_Read_Fields($obj, $dat, $fields)"
Given a block of data large enough to account for all the fields in a table,
processes the data block to convert to the values in the objects instance
variables by name based on the list in the \f(CW\*(C`DATA\*(C'\fR block which has been run
through \f(CW\*(C`TTF_Init_Fields\*(C'\fR
.ie n .SS "TTF_Unpack($fmt, $dat)"
.el .SS "TTF_Unpack($fmt, \f(CW$dat\fP)"
.IX Subsection "TTF_Unpack($fmt, $dat)"
A TrueType types equivalent of Perls \f(CW\*(C`unpack\*(C'\fR function. Thus \f(CW$fmt\fR consists of
type followed by an optional number of elements to read including *. The type
may be one of:
.PP
.Vb 9
\&    c       BYTE
\&    C       CHAR
\&    f       FIXED
\&    F       F2DOT14
\&    l       LONG
\&    L       ULONG
\&    s       SHORT
\&    S       USHORT
\&    v       Version number (FIXED)
.Ve
.PP
Note that \f(CW\*(C`FUNIT\*(C'\fR, \f(CW\*(C`FWORD\*(C'\fR and \f(CW\*(C`UFWORD\*(C'\fR are not data types but units.
.PP
Returns array of scalar (first element) depending on context
.ie n .SS "$dat = TTF_Out_Fields($obj, $fields, $len)"
.el .SS "\f(CW$dat\fP = TTF_Out_Fields($obj, \f(CW$fields\fP, \f(CW$len\fP)"
.IX Subsection "$dat = TTF_Out_Fields($obj, $fields, $len)"
Given the fields table from \f(CW\*(C`TTF_Init_Fields\*(C'\fR writes out the instance variables from
the object to the filehandle in \s-1TTF\s0 binary form.
.ie n .SS "$dat = TTF_Pack($fmt, @data)"
.el .SS "\f(CW$dat\fP = TTF_Pack($fmt, \f(CW@data\fP)"
.IX Subsection "$dat = TTF_Pack($fmt, @data)"
The TrueType equivalent to Perl's \f(CW\*(C`pack\*(C'\fR function. See details of \f(CW\*(C`TTF_Unpack\*(C'\fR
for how to work the \f(CW$fmt\fR string.
.ie n .SS "($num, $range, $select, $shift) = TTF_bininfo($num)"
.el .SS "($num, \f(CW$range\fP, \f(CW$select\fP, \f(CW$shift\fP) = TTF_bininfo($num)"
.IX Subsection "($num, $range, $select, $shift) = TTF_bininfo($num)"
Calculates binary search information from a number of elements
.SS "TTF_word_utf8($str)"
.IX Subsection "TTF_word_utf8($str)"
Returns the \s-1UTF8\s0 form of the 16 bit string, assumed to be in big endian order,
including surrogate handling
.SS "TTF_utf8_word($str)"
.IX Subsection "TTF_utf8_word($str)"
Returns the 16\-bit form in big endian order of the \s-1UTF\s0 8 string, including
surrogate handling to Unicode.
.ie n .SS "XML_hexdump($context, $dat)"
.el .SS "XML_hexdump($context, \f(CW$dat\fP)"
.IX Subsection "XML_hexdump($context, $dat)"
Dumps out the given data as a sequence of <data> blocks each 16 bytes wide
.SS "XML_outhints"
.IX Subsection "XML_outhints"
Converts a binary string of hinting code into a textual representation
.ie n .SS "make_circle($f, $cmap, [$dia, $sb, $opts])"
.el .SS "make_circle($f, \f(CW$cmap\fP, [$dia, \f(CW$sb\fP, \f(CW$opts\fP])"
.IX Subsection "make_circle($f, $cmap, [$dia, $sb, $opts])"
Adds a dotted circle to a font. This function is very configurable. The
parameters passed in are:
.ie n .IP "$f" 4
.el .IP "\f(CW$f\fR" 4
.IX Item "$f"
Font to work with. This is required.
.ie n .IP "$cmap" 4
.el .IP "\f(CW$cmap\fR" 4
.IX Item "$cmap"
A cmap table (not the 'val' sub-element of a cmap) to add the glyph too. Optional.
.ie n .IP "$dia" 4
.el .IP "\f(CW$dia\fR" 4
.IX Item "$dia"
Optional diameter for the main circle. Defaults to 80% em
.ie n .IP "$sb" 4
.el .IP "\f(CW$sb\fR" 4
.IX Item "$sb"
Side bearing. The left and right side-bearings are always the same. This value
defaults to 10% em.
.PP
There are various options to control all sorts of interesting aspects of the circle
.IP "numDots" 4
.IX Item "numDots"
Number of dots in the circle
.IP "numPoints" 4
.IX Item "numPoints"
Number of curve points to use to create each dot
.IP "uid" 4
.IX Item "uid"
Unicode reference to store this glyph under in the cmap. Defaults to 0x25CC
.IP "pname" 4
.IX Item "pname"
Postscript name to give the glyph. Defaults to uni25CC.
.IP "\-dRadius" 4
.IX Item "-dRadius"
Radius of each dot.
.SH "BUGS"
.IX Header "BUGS"
No known bugs
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken <http://scripts.sil.org/FontUtils>.
.SH "LICENSING"
.IX Header "LICENSING"
Copyright (c) 1998\-2014, \s-1SIL\s0 International (http://www.sil.org)
.PP
This module is released under the terms of the Artistic License 2.0. 
For details, see the full text of the license in the file \s-1LICENSE\s0.
