.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Critic::Utils 3"
.TH Perl::Critic::Utils 3 "2012-07-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::Critic::Utils \- General utility subroutines and constants for Perl::Critic and derivative distributions.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides several static subs and variables that are useful
for developing Perl::Critic::Policy
subclasses.  Unless you are writing Policy modules, you probably don't
care about this package.
.SH "INTERFACE SUPPORT"
.IX Header "INTERFACE SUPPORT"
This is considered to be a public module.  Any changes to its
interface will go through a deprecation cycle.
.SH "IMPORTABLE SUBS"
.IX Header "IMPORTABLE SUBS"
.ie n .IP """find_keywords( $doc, $keyword )""" 4
.el .IP "\f(CWfind_keywords( $doc, $keyword )\fR" 4
.IX Item "find_keywords( $doc, $keyword )"
\&\fB\s-1DEPRECATED:\s0\fR Since version 0.11, every Policy is evaluated at each
element of the document.  So you shouldn't need to go looking for a
particular keyword.  If you \fIdo\fR want to use this, please import it
via the \f(CW\*(C`:deprecated\*(C'\fR tag, rather than directly, to mark the module
as needing updating.
.Sp
Given a PPI::Document as \f(CW$doc\fR, returns a reference
to an array containing all the PPI::Token::Word
elements that match \f(CW$keyword\fR.  This can be used to find any
built-in function, method call, bareword, or reserved keyword.  It
will not match variables, subroutine names, literal strings, numbers,
or symbols.  If the document doesn't contain any matches, returns
undef.
.ie n .IP """is_perl_global( $element )""" 4
.el .IP "\f(CWis_perl_global( $element )\fR" 4
.IX Item "is_perl_global( $element )"
Given a PPI::Token::Symbol or a string, returns
true if that token represents one of the global variables provided by
the English module, or one of the builtin global variables
like \f(CW%SIG\fR, \f(CW%ENV\fR, or \f(CW@ARGV\fR.  The sigil on the symbol is
ignored, so things like \f(CW$ARGV\fR or \f(CW$ENV\fR will still return true.
.ie n .IP """is_perl_builtin( $element )""" 4
.el .IP "\f(CWis_perl_builtin( $element )\fR" 4
.IX Item "is_perl_builtin( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8.
.ie n .IP """is_perl_bareword( $element )""" 4
.el .IP "\f(CWis_perl_bareword( $element )\fR" 4
.IX Item "is_perl_bareword( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a bareword (e.g. \*(L"if\*(R", \*(L"else\*(R", \*(L"sub\*(R", \*(L"package\*(R")
defined in Perl 5.8.8.
.ie n .IP """is_perl_filehandle( $element )""" 4
.el .IP "\f(CWis_perl_filehandle( $element )\fR" 4
.IX Item "is_perl_filehandle( $element )"
Given a PPI::Token::Word, or string, returns true
if that token represents one of the global filehandles (e.g. \f(CW\*(C`STDIN\*(C'\fR,
\&\f(CW\*(C`STDERR\*(C'\fR, \f(CW\*(C`STDOUT\*(C'\fR, \f(CW\*(C`ARGV\*(C'\fR) that are defined in Perl 5.8.8.  Note
that this function will return false if given a filehandle that is
represented as a typeglob (e.g. \f(CW*STDIN\fR)
.ie n .IP """is_perl_builtin_with_list_context( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_list_context( $element )\fR" 4
.IX Item "is_perl_builtin_with_list_context( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that provide a list context to the following tokens.
.ie n .IP """is_perl_builtin_with_multiple_arguments( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_multiple_arguments( $element )\fR" 4
.IX Item "is_perl_builtin_with_multiple_arguments( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that \fBcan\fR take multiple arguments.
.ie n .IP """is_perl_builtin_with_no_arguments( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_no_arguments( $element )\fR" 4
.IX Item "is_perl_builtin_with_no_arguments( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that \fBcannot\fR take any arguments.
.ie n .IP """is_perl_builtin_with_one_argument( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_one_argument( $element )\fR" 4
.IX Item "is_perl_builtin_with_one_argument( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that takes \fBone and only one\fR argument.
.ie n .IP """is_perl_builtin_with_optional_argument( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_optional_argument( $element )\fR" 4
.IX Item "is_perl_builtin_with_optional_argument( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that takes \fBno more than one\fR argument.
.Sp
The sets of values for which
\&\f(CW\*(C`is_perl_builtin_with_multiple_arguments()\*(C'\fR,
\&\f(CW\*(C`is_perl_builtin_with_no_arguments()\*(C'\fR,
\&\f(CW\*(C`is_perl_builtin_with_one_argument()\*(C'\fR, and
\&\f(CW\*(C`is_perl_builtin_with_optional_argument()\*(C'\fR return true are disjoint
and their union is precisely the set of values that
\&\f(CW\*(C`is_perl_builtin()\*(C'\fR will return true for.
.ie n .IP """is_perl_builtin_with_zero_and_or_one_arguments( $element )""" 4
.el .IP "\f(CWis_perl_builtin_with_zero_and_or_one_arguments( $element )\fR" 4
.IX Item "is_perl_builtin_with_zero_and_or_one_arguments( $element )"
Given a PPI::Token::Word,
PPI::Statement::Sub, or string, returns true if
that token represents a call to any of the builtin functions defined
in Perl 5.8.8 that takes no and/or one argument.
.Sp
Returns true if any of \f(CW\*(C`is_perl_builtin_with_no_arguments()\*(C'\fR,
\&\f(CW\*(C`is_perl_builtin_with_one_argument()\*(C'\fR, and
\&\f(CW\*(C`is_perl_builtin_with_optional_argument()\*(C'\fR returns true.
.ie n .IP """is_qualified_name( $name )""" 4
.el .IP "\f(CWis_qualified_name( $name )\fR" 4
.IX Item "is_qualified_name( $name )"
Given a string, PPI::Token::Word, or
PPI::Token::Symbol, answers whether it has a
module component, i.e. contains \*(L"::\*(R".
.ie n .IP """precedence_of( $element )""" 4
.el .IP "\f(CWprecedence_of( $element )\fR" 4
.IX Item "precedence_of( $element )"
Given a PPI::Token::Operator or a string,
returns the precedence of the operator, where 1 is the highest
precedence.  Returns undef if the precedence can't be determined
(which is usually because it is not an operator).
.ie n .IP """is_hash_key( $element )""" 4
.el .IP "\f(CWis_hash_key( $element )\fR" 4
.IX Item "is_hash_key( $element )"
Given a PPI::Element, returns true if the element is a
literal hash key.  \s-1PPI\s0 doesn't distinguish between regular barewords
(like keywords or subroutine calls) and barewords in hash subscripts
(which are considered literal).  So this subroutine is useful if your
Policy is searching for PPI::Token::Word elements
and you want to filter out the hash subscript variety.  In both of the
following examples, \*(L"foo\*(R" is considered a hash key:
.Sp
.Vb 2
\&    $hash1{foo} = 1;
\&    %hash2 = (foo => 1);
.Ve
.Sp
But if the bareword is followed by an argument list, then perl treats
it as a function call.  So in these examples, \*(L"foo\*(R" is \fBnot\fR
considered a hash key:
.Sp
.Vb 2
\&    $hash1{ foo() } = 1;
\&    &hash2 = (foo() => 1);
.Ve
.ie n .IP """is_included_module_name( $element )""" 4
.el .IP "\f(CWis_included_module_name( $element )\fR" 4
.IX Item "is_included_module_name( $element )"
Given a PPI::Token::Word, returns true if the
element is the name of a module that is being included via \f(CW\*(C`use\*(C'\fR,
\&\f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`no\*(C'\fR.
.ie n .IP """is_integer( $value )""" 4
.el .IP "\f(CWis_integer( $value )\fR" 4
.IX Item "is_integer( $value )"
Answers whether the parameter, as a string, looks like an integral
value.
.ie n .IP """is_class_name( $element )""" 4
.el .IP "\f(CWis_class_name( $element )\fR" 4
.IX Item "is_class_name( $element )"
Given a PPI::Token::Word, returns true if the
element that immediately follows this element is the dereference
operator \*(L"\->\*(R". When a bareword has a \*(L"\->\*(R" on the \fBright\fR side, it
usually means that it is the name of the class (from which a method is
being called).
.ie n .IP """is_label_pointer( $element )""" 4
.el .IP "\f(CWis_label_pointer( $element )\fR" 4
.IX Item "is_label_pointer( $element )"
Given a PPI::Token::Word, returns true if the
element is the label in a \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`redo\*(C'\fR, or \f(CW\*(C`goto\*(C'\fR
statement.  Note this is not the same thing as the label declaration.
.ie n .IP """is_method_call( $element )""" 4
.el .IP "\f(CWis_method_call( $element )\fR" 4
.IX Item "is_method_call( $element )"
Given a PPI::Token::Word, returns true if the
element that immediately precedes this element is the dereference
operator \*(L"\->\*(R". When a bareword has a \*(L"\->\*(R" on the \fBleft\fR side, it
usually means that it is the name of a method (that is being called
from a class).
.ie n .IP """is_package_declaration( $element )""" 4
.el .IP "\f(CWis_package_declaration( $element )\fR" 4
.IX Item "is_package_declaration( $element )"
Given a PPI::Token::Word, returns true if the
element is the name of a package that is being declared.
.ie n .IP """is_subroutine_name( $element )""" 4
.el .IP "\f(CWis_subroutine_name( $element )\fR" 4
.IX Item "is_subroutine_name( $element )"
Given a PPI::Token::Word, returns true if the
element is the name of a subroutine declaration.  This is useful for
distinguishing barewords and from function calls from subroutine
declarations.
.ie n .IP """is_function_call( $element )""" 4
.el .IP "\f(CWis_function_call( $element )\fR" 4
.IX Item "is_function_call( $element )"
Given a PPI::Token::Word returns true if the
element appears to be call to a static function.  Specifically, this
function returns true if \f(CW\*(C`is_hash_key\*(C'\fR, \f(CW\*(C`is_method_call\*(C'\fR,
\&\f(CW\*(C`is_subroutine_name\*(C'\fR, \f(CW\*(C`is_included_module_name\*(C'\fR,
\&\f(CW\*(C`is_package_declaration\*(C'\fR, \f(CW\*(C`is_perl_bareword\*(C'\fR, \f(CW\*(C`is_perl_filehandle\*(C'\fR,
\&\f(CW\*(C`is_label_pointer\*(C'\fR and \f(CW\*(C`is_subroutine_name\*(C'\fR all return false for the
given element.
.ie n .IP """first_arg( $element )""" 4
.el .IP "\f(CWfirst_arg( $element )\fR" 4
.IX Item "first_arg( $element )"
Given a PPI::Element that is presumed to be a function
call (which is usually a PPI::Token::Word), return
the first argument.  This is similar of \f(CW\*(C`parse_arg_list()\*(C'\fR and
follows the same logic.  Note that for the code:
.Sp
.Vb 1
\&    int($x + 0.5)
.Ve
.Sp
this function will return just the \f(CW$x\fR, not the whole expression.
This is different from the behavior of \f(CW\*(C`parse_arg_list()\*(C'\fR.  Another
caveat is:
.Sp
.Vb 1
\&    int(($x + $y) + 0.5)
.Ve
.Sp
which returns \f(CW\*(C`($x + $y)\*(C'\fR as a
PPI::Structure::List instance.
.ie n .IP """parse_arg_list( $element )""" 4
.el .IP "\f(CWparse_arg_list( $element )\fR" 4
.IX Item "parse_arg_list( $element )"
Given a PPI::Element that is presumed to be a function
call (which is usually a PPI::Token::Word), splits
the argument expressions into arrays of tokens.  Returns a list
containing references to each of those arrays.  This is useful because
parentheses are optional when calling a function, and \s-1PPI\s0 parses them
very differently.  So this method is a poor-man's parse tree of \s-1PPI\s0
nodes.  It's not bullet-proof because it doesn't respect precedence.
In general, I don't like the way this function works, so don't count
on it to be stable (or even present).
.ie n .IP """split_nodes_on_comma( @nodes )""" 4
.el .IP "\f(CWsplit_nodes_on_comma( @nodes )\fR" 4
.IX Item "split_nodes_on_comma( @nodes )"
This has the same return type as \f(CW\*(C`parse_arg_list()\*(C'\fR but expects to be
passed the nodes that represent the interior of a list, like:
.Sp
.Vb 1
\&    \*(Aqfoo\*(Aq, 1, 2, \*(Aqbar\*(Aq
.Ve
.ie n .IP """is_script( $document )""" 4
.el .IP "\f(CWis_script( $document )\fR" 4
.IX Item "is_script( $document )"
\&\fBThis subroutine is deprecated and will be removed in a future release.\fR You
should use the \*(L"\fIis_program()\fR\*(R" in Perl::Critic::Document method instead.
.ie n .IP """is_in_void_context( $token )""" 4
.el .IP "\f(CWis_in_void_context( $token )\fR" 4
.IX Item "is_in_void_context( $token )"
Given a PPI::Token, answer whether it appears to be in a
void context.
.ie n .IP """policy_long_name( $policy_name )""" 4
.el .IP "\f(CWpolicy_long_name( $policy_name )\fR" 4
.IX Item "policy_long_name( $policy_name )"
Given a policy class name in long or short form, return the long form.
.ie n .IP """policy_short_name( $policy_name )""" 4
.el .IP "\f(CWpolicy_short_name( $policy_name )\fR" 4
.IX Item "policy_short_name( $policy_name )"
Given a policy class name in long or short form, return the short
form.
.ie n .IP """all_perl_files( @directories )""" 4
.el .IP "\f(CWall_perl_files( @directories )\fR" 4
.IX Item "all_perl_files( @directories )"
Given a list of directories, recursively searches through all the
directories (depth first) and returns a list of paths for all the
files that are Perl code files.  Any administrative files for \s-1CVS\s0 or
Subversion are skipped, as are things that look like temporary or
backup files.
.Sp
A Perl code file is:
.RS 4
.IP "\(bu" 4
Any file that ends in \fI.PL\fR, \fI.pl\fR, \fI.pm\fR, or \fI.t\fR
.IP "\(bu" 4
Any file that has a first line with a shebang containing 'perl'
.RE
.RS 4
.RE
.ie n .IP """severity_to_number( $severity )""" 4
.el .IP "\f(CWseverity_to_number( $severity )\fR" 4
.IX Item "severity_to_number( $severity )"
If \f(CW$severity\fR is given as an integer, this function returns
\&\f(CW$severity\fR but normalized to lie between \f(CW$SEVERITY_LOWEST\fR and
\&\f(CW$SEVERITY_HIGHEST\fR.  If \f(CW$severity\fR is given as a string, this
function returns the corresponding severity number.  If the string
doesn't have a corresponding number, this function will throw an
exception.
.ie n .IP """is_valid_numeric_verbosity( $severity )""" 4
.el .IP "\f(CWis_valid_numeric_verbosity( $severity )\fR" 4
.IX Item "is_valid_numeric_verbosity( $severity )"
Answers whether the argument has a translation to a Violation format.
.ie n .IP """verbosity_to_format( $verbosity_level )""" 4
.el .IP "\f(CWverbosity_to_format( $verbosity_level )\fR" 4
.IX Item "verbosity_to_format( $verbosity_level )"
Given a verbosity level between 1 and 10, returns the corresponding
predefined format string.  These formats are suitable for passing to
the \f(CW\*(C`set_format\*(C'\fR method in
Perl::Critic::Violation.  See the
perlcritic documentation for a listing of the predefined
formats.
.ie n .IP """hashify( @list )""" 4
.el .IP "\f(CWhashify( @list )\fR" 4
.IX Item "hashify( @list )"
Given \f(CW@list\fR, return a hash where \f(CW@list\fR is in the keys and each
value is 1.  Duplicate values in \f(CW@list\fR are silently squished.
.ie n .IP """interpolate( $literal )""" 4
.el .IP "\f(CWinterpolate( $literal )\fR" 4
.IX Item "interpolate( $literal )"
Given a \f(CW$literal\fR string that may contain control characters (e.g..
\&'\et' '\en'), this function does a double interpolation on the string
and returns it as if it had been declared in double quotes.  For
example:
.Sp
.Vb 1
\&    \*(Aqfoo \et bar \en\*(Aq ...becomes... "foo \et bar \en"
.Ve
.ie n .IP """shebang_line( $document )""" 4
.el .IP "\f(CWshebang_line( $document )\fR" 4
.IX Item "shebang_line( $document )"
Given a PPI::Document, test if it starts with \f(CW\*(C`#!\*(C'\fR.
If so, return that line.  Otherwise return undef.
.ie n .IP """words_from_string( $str )""" 4
.el .IP "\f(CWwords_from_string( $str )\fR" 4
.IX Item "words_from_string( $str )"
Given config string \fI\f(CI$str\fI\fR, return all the words from the string.
This is safer than splitting on whitespace.
.ie n .IP """is_unchecked_call( $element )""" 4
.el .IP "\f(CWis_unchecked_call( $element )\fR" 4
.IX Item "is_unchecked_call( $element )"
Given a PPI::Element, test to see if it contains a
function call whose return value is not checked.
.SH "IMPORTABLE VARIABLES"
.IX Header "IMPORTABLE VARIABLES"
.ie n .IP "$COMMA" 4
.el .IP "\f(CW$COMMA\fR" 4
.IX Item "$COMMA"
.PD 0
.ie n .IP "$FATCOMMA" 4
.el .IP "\f(CW$FATCOMMA\fR" 4
.IX Item "$FATCOMMA"
.ie n .IP "$COLON" 4
.el .IP "\f(CW$COLON\fR" 4
.IX Item "$COLON"
.ie n .IP "$SCOLON" 4
.el .IP "\f(CW$SCOLON\fR" 4
.IX Item "$SCOLON"
.ie n .IP "$QUOTE" 4
.el .IP "\f(CW$QUOTE\fR" 4
.IX Item "$QUOTE"
.ie n .IP "$DQUOTE" 4
.el .IP "\f(CW$DQUOTE\fR" 4
.IX Item "$DQUOTE"
.ie n .IP "$BACKTICK" 4
.el .IP "\f(CW$BACKTICK\fR" 4
.IX Item "$BACKTICK"
.ie n .IP "$PERIOD" 4
.el .IP "\f(CW$PERIOD\fR" 4
.IX Item "$PERIOD"
.ie n .IP "$PIPE" 4
.el .IP "\f(CW$PIPE\fR" 4
.IX Item "$PIPE"
.ie n .IP "$EMPTY" 4
.el .IP "\f(CW$EMPTY\fR" 4
.IX Item "$EMPTY"
.ie n .IP "$EQUAL" 4
.el .IP "\f(CW$EQUAL\fR" 4
.IX Item "$EQUAL"
.ie n .IP "$SPACE" 4
.el .IP "\f(CW$SPACE\fR" 4
.IX Item "$SPACE"
.ie n .IP "$SLASH" 4
.el .IP "\f(CW$SLASH\fR" 4
.IX Item "$SLASH"
.ie n .IP "$BSLASH" 4
.el .IP "\f(CW$BSLASH\fR" 4
.IX Item "$BSLASH"
.ie n .IP "$LEFT_PAREN" 4
.el .IP "\f(CW$LEFT_PAREN\fR" 4
.IX Item "$LEFT_PAREN"
.ie n .IP "$RIGHT_PAREN" 4
.el .IP "\f(CW$RIGHT_PAREN\fR" 4
.IX Item "$RIGHT_PAREN"
.PD
These character constants give clear names to commonly-used strings
that can be hard to read when surrounded by quotes and other
punctuation.  Can be imported in one go via the \f(CW\*(C`:characters\*(C'\fR tag.
.ie n .IP "$SEVERITY_HIGHEST" 4
.el .IP "\f(CW$SEVERITY_HIGHEST\fR" 4
.IX Item "$SEVERITY_HIGHEST"
.PD 0
.ie n .IP "$SEVERITY_HIGH" 4
.el .IP "\f(CW$SEVERITY_HIGH\fR" 4
.IX Item "$SEVERITY_HIGH"
.ie n .IP "$SEVERITY_MEDIUM" 4
.el .IP "\f(CW$SEVERITY_MEDIUM\fR" 4
.IX Item "$SEVERITY_MEDIUM"
.ie n .IP "$SEVERITY_LOW" 4
.el .IP "\f(CW$SEVERITY_LOW\fR" 4
.IX Item "$SEVERITY_LOW"
.ie n .IP "$SEVERITY_LOWEST" 4
.el .IP "\f(CW$SEVERITY_LOWEST\fR" 4
.IX Item "$SEVERITY_LOWEST"
.PD
These numeric constants define the relative severity of violating each
Perl::Critic::Policy.  The \f(CW\*(C`get_severity\*(C'\fR and
\&\f(CW\*(C`default_severity\*(C'\fR methods of every Policy subclass must return one
of these values. Can be imported via the \f(CW\*(C`:severities\*(C'\fR tag.
.ie n .IP "$DEFAULT_VERBOSITY" 4
.el .IP "\f(CW$DEFAULT_VERBOSITY\fR" 4
.IX Item "$DEFAULT_VERBOSITY"
The default numeric verbosity.
.ie n .IP "$DEFAULT_VERBOSITY_WITH_FILE_NAME" 4
.el .IP "\f(CW$DEFAULT_VERBOSITY_WITH_FILE_NAME\fR" 4
.IX Item "$DEFAULT_VERBOSITY_WITH_FILE_NAME"
The numeric verbosity that corresponds to the format indicated by
\&\f(CW$DEFAULT_VERBOSITY\fR, but with the file name prefixed to it.
.ie n .IP "$TRUE" 4
.el .IP "\f(CW$TRUE\fR" 4
.IX Item "$TRUE"
.PD 0
.ie n .IP "$FALSE" 4
.el .IP "\f(CW$FALSE\fR" 4
.IX Item "$FALSE"
.PD
These are simple booleans. 1 and 0 respectively.  Be mindful of using
these with string equality.  \f(CW\*(C`$FALSE ne $EMPTY\*(C'\fR.  Can be imported via
the \f(CW\*(C`:booleans\*(C'\fR tag.
.SH "IMPORT TAGS"
.IX Header "IMPORT TAGS"
The following groups of functions and constants are available as
parameters to a \f(CW\*(C`use Perl::Critic::Util\*(C'\fR statement.
.ie n .IP """:all""" 4
.el .IP "\f(CW:all\fR" 4
.IX Item ":all"
The lot.
.ie n .IP """:booleans""" 4
.el .IP "\f(CW:booleans\fR" 4
.IX Item ":booleans"
Includes:
\&\f(CW$TRUE\fR, \f(CW$FALSE\fR
.ie n .IP """:severities""" 4
.el .IP "\f(CW:severities\fR" 4
.IX Item ":severities"
Includes:
\&\f(CW$SEVERITY_HIGHEST\fR,
\&\f(CW$SEVERITY_HIGH\fR,
\&\f(CW$SEVERITY_MEDIUM\fR,
\&\f(CW$SEVERITY_LOW\fR,
\&\f(CW$SEVERITY_LOWEST\fR,
\&\f(CW@SEVERITY_NAMES\fR
.ie n .IP """:characters""" 4
.el .IP "\f(CW:characters\fR" 4
.IX Item ":characters"
Includes:
\&\f(CW$COLON\fR,
\&\f(CW$COMMA\fR,
\&\f(CW$DQUOTE\fR,
\&\f(CW$EMPTY\fR,
\&\f(CW$FATCOMMA\fR,
\&\f(CW$PERIOD\fR,
\&\f(CW$PIPE\fR,
\&\f(CW$QUOTE\fR,
\&\f(CW$BACKTICK\fR,
\&\f(CW$SCOLON\fR,
\&\f(CW$SPACE\fR,
\&\f(CW$SLASH\fR,
\&\f(CW$BSLASH\fR
\&\f(CW$LEFT_PAREN\fR
\&\f(CW$RIGHT_PAREN\fR
.ie n .IP """:classification""" 4
.el .IP "\f(CW:classification\fR" 4
.IX Item ":classification"
Includes:
\&\f(CW\*(C`is_function_call\*(C'\fR,
\&\f(CW\*(C`is_hash_key\*(C'\fR,
\&\f(CW\*(C`is_included_module_name\*(C'\fR,
\&\f(CW\*(C`is_integer\*(C'\fR,
\&\f(CW\*(C`is_method_call\*(C'\fR,
\&\f(CW\*(C`is_package_declaration\*(C'\fR,
\&\f(CW\*(C`is_perl_builtin\*(C'\fR,
\&\f(CW\*(C`is_perl_global\*(C'\fR,
\&\f(CW\*(C`is_perl_builtin_with_list_context\*(C'\fR
\&\f(CW\*(C`is_perl_builtin_with_multiple_arguments\*(C'\fR
\&\f(CW\*(C`is_perl_builtin_with_no_arguments\*(C'\fR
\&\f(CW\*(C`is_perl_builtin_with_one_argument\*(C'\fR
\&\f(CW\*(C`is_perl_builtin_with_optional_argument\*(C'\fR
\&\f(CW\*(C`is_perl_builtin_with_zero_and_or_one_arguments\*(C'\fR
\&\f(CW\*(C`is_script\*(C'\fR,
\&\f(CW\*(C`is_subroutine_name\*(C'\fR,
\&\f(CW\*(C`is_unchecked_call\*(C'\fR
\&\f(CW\*(C`is_valid_numeric_verbosity\*(C'\fR
.Sp
See also Perl::Critic::Utils::PPI.
.ie n .IP """:data_conversion""" 4
.el .IP "\f(CW:data_conversion\fR" 4
.IX Item ":data_conversion"
Generic manipulation, not having anything specific to do with
Perl::Critic.
.Sp
Includes:
\&\f(CW\*(C`hashify\*(C'\fR,
\&\f(CW\*(C`words_from_string\*(C'\fR,
\&\f(CW\*(C`interpolate\*(C'\fR
.ie n .IP """:ppi""" 4
.el .IP "\f(CW:ppi\fR" 4
.IX Item ":ppi"
Things for dealing with \s-1PPI\s0, other than classification.
.Sp
Includes:
\&\f(CW\*(C`first_arg\*(C'\fR,
\&\f(CW\*(C`parse_arg_list\*(C'\fR
.Sp
See also Perl::Critic::Utils::PPI.
.ie n .IP """:internal_lookup""" 4
.el .IP "\f(CW:internal_lookup\fR" 4
.IX Item ":internal_lookup"
Translations between internal representations.
.Sp
Includes:
\&\f(CW\*(C`severity_to_number\*(C'\fR,
\&\f(CW\*(C`verbosity_to_format\*(C'\fR
.ie n .IP """:language""" 4
.el .IP "\f(CW:language\fR" 4
.IX Item ":language"
Information about Perl not programmatically available elsewhere.
.Sp
Includes:
\&\f(CW\*(C`precedence_of\*(C'\fR
.ie n .IP """:deprecated""" 4
.el .IP "\f(CW:deprecated\fR" 4
.IX Item ":deprecated"
Not surprisingly, things that are deprecated.  It is preferred to use
this tag to get to these functions, rather than the function names
themselves, so as to mark any module using them as needing cleanup.
.Sp
Includes:
\&\f(CW\*(C`find_keywords\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Perl::Critic::Utils::Constants,
Perl::Critic::Utils::McCabe,
Perl::Critic::Utils::PPI,
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeffrey Ryan Thalhammer <jeff@imaginative\-software.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005\-2011 Imaginative Software Systems.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the \s-1LICENSE\s0 file included with this module.
